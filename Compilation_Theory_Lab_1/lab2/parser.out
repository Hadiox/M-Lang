Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ADDASSIGN
    BREAK
    CONTINUE
    DIVASSIGN
    DOTADD
    DOTDIV
    DOTMUL
    DOTSUB
    ELSE
    EYE
    FLOAT
    FOR
    MULASSIGN
    NEQ
    ONES
    PRINT
    RETURN
    STRING
    SUBASSIGN
    THEN
    WHILE
    ZEROS

Grammar

Rule 0     S' -> program
Rule 1     program -> instructions_opt
Rule 2     instructions_opt -> instructions
Rule 3     instructions_opt -> <empty>
Rule 4     instructions -> instructions instruction
Rule 5     instructions -> instruction
Rule 6     instruction -> if_statement
Rule 7     if_statement -> IF ( condition ) { instructions }
Rule 8     condition -> variable logical_operator variable
Rule 9     logical_operator -> EQ
Rule 10    logical_operator -> <
Rule 11    logical_operator -> >
Rule 12    logical_operator -> GE
Rule 13    logical_operator -> LE
Rule 14    variable -> INTNUM
Rule 15    variable -> ID
Rule 16    instruction -> assign
Rule 17    assign -> ID = INTNUM
Rule 18    assign -> ID = ID
Rule 19    assign -> ID = EXPRESSION
Rule 20    EXPRESSION -> INTNUM + INTNUM

Terminals, with rules where they appear

(                    : 7
)                    : 7
+                    : 20
<                    : 10
=                    : 17 18 19
>                    : 11
ADDASSIGN            : 
BREAK                : 
CONTINUE             : 
DIVASSIGN            : 
DOTADD               : 
DOTDIV               : 
DOTMUL               : 
DOTSUB               : 
ELSE                 : 
EQ                   : 9
EYE                  : 
FLOAT                : 
FOR                  : 
GE                   : 12
ID                   : 15 17 18 18 19
IF                   : 7
INTNUM               : 14 17 20 20
LE                   : 13
MULASSIGN            : 
NEQ                  : 
ONES                 : 
PRINT                : 
RETURN               : 
STRING               : 
SUBASSIGN            : 
THEN                 : 
WHILE                : 
ZEROS                : 
error                : 
{                    : 7
}                    : 7

Nonterminals, with rules where they appear

EXPRESSION           : 19
assign               : 16
condition            : 7
if_statement         : 6
instruction          : 4 5
instructions         : 2 4 7
instructions_opt     : 1
logical_operator     : 8
program              : 0
variable             : 8 8

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . instructions_opt
    (2) instructions_opt -> . instructions
    (3) instructions_opt -> .
    (4) instructions -> . instructions instruction
    (5) instructions -> . instruction
    (6) instruction -> . if_statement
    (16) instruction -> . assign
    (7) if_statement -> . IF ( condition ) { instructions }
    (17) assign -> . ID = INTNUM
    (18) assign -> . ID = ID
    (19) assign -> . ID = EXPRESSION

    $end            reduce using rule 3 (instructions_opt -> .)
    IF              shift and go to state 7
    ID              shift and go to state 8

    program                        shift and go to state 1
    instructions_opt               shift and go to state 2
    instructions                   shift and go to state 3
    instruction                    shift and go to state 4
    if_statement                   shift and go to state 5
    assign                         shift and go to state 6

state 1

    (0) S' -> program .



state 2

    (1) program -> instructions_opt .

    $end            reduce using rule 1 (program -> instructions_opt .)


state 3

    (2) instructions_opt -> instructions .
    (4) instructions -> instructions . instruction
    (6) instruction -> . if_statement
    (16) instruction -> . assign
    (7) if_statement -> . IF ( condition ) { instructions }
    (17) assign -> . ID = INTNUM
    (18) assign -> . ID = ID
    (19) assign -> . ID = EXPRESSION

    $end            reduce using rule 2 (instructions_opt -> instructions .)
    IF              shift and go to state 7
    ID              shift and go to state 8

    instruction                    shift and go to state 9
    if_statement                   shift and go to state 5
    assign                         shift and go to state 6

state 4

    (5) instructions -> instruction .

    IF              reduce using rule 5 (instructions -> instruction .)
    ID              reduce using rule 5 (instructions -> instruction .)
    $end            reduce using rule 5 (instructions -> instruction .)
    }               reduce using rule 5 (instructions -> instruction .)


state 5

    (6) instruction -> if_statement .

    IF              reduce using rule 6 (instruction -> if_statement .)
    ID              reduce using rule 6 (instruction -> if_statement .)
    $end            reduce using rule 6 (instruction -> if_statement .)
    }               reduce using rule 6 (instruction -> if_statement .)


state 6

    (16) instruction -> assign .

    IF              reduce using rule 16 (instruction -> assign .)
    ID              reduce using rule 16 (instruction -> assign .)
    $end            reduce using rule 16 (instruction -> assign .)
    }               reduce using rule 16 (instruction -> assign .)


state 7

    (7) if_statement -> IF . ( condition ) { instructions }

    (               shift and go to state 10


state 8

    (17) assign -> ID . = INTNUM
    (18) assign -> ID . = ID
    (19) assign -> ID . = EXPRESSION

    =               shift and go to state 11


state 9

    (4) instructions -> instructions instruction .

    IF              reduce using rule 4 (instructions -> instructions instruction .)
    ID              reduce using rule 4 (instructions -> instructions instruction .)
    $end            reduce using rule 4 (instructions -> instructions instruction .)
    }               reduce using rule 4 (instructions -> instructions instruction .)


state 10

    (7) if_statement -> IF ( . condition ) { instructions }
    (8) condition -> . variable logical_operator variable
    (14) variable -> . INTNUM
    (15) variable -> . ID

    INTNUM          shift and go to state 14
    ID              shift and go to state 15

    condition                      shift and go to state 12
    variable                       shift and go to state 13

state 11

    (17) assign -> ID = . INTNUM
    (18) assign -> ID = . ID
    (19) assign -> ID = . EXPRESSION
    (20) EXPRESSION -> . INTNUM + INTNUM

    INTNUM          shift and go to state 17
    ID              shift and go to state 16

    EXPRESSION                     shift and go to state 18

state 12

    (7) if_statement -> IF ( condition . ) { instructions }

    )               shift and go to state 19


state 13

    (8) condition -> variable . logical_operator variable
    (9) logical_operator -> . EQ
    (10) logical_operator -> . <
    (11) logical_operator -> . >
    (12) logical_operator -> . GE
    (13) logical_operator -> . LE

    EQ              shift and go to state 21
    <               shift and go to state 22
    >               shift and go to state 23
    GE              shift and go to state 24
    LE              shift and go to state 25

    logical_operator               shift and go to state 20

state 14

    (14) variable -> INTNUM .

    EQ              reduce using rule 14 (variable -> INTNUM .)
    <               reduce using rule 14 (variable -> INTNUM .)
    >               reduce using rule 14 (variable -> INTNUM .)
    GE              reduce using rule 14 (variable -> INTNUM .)
    LE              reduce using rule 14 (variable -> INTNUM .)
    )               reduce using rule 14 (variable -> INTNUM .)


state 15

    (15) variable -> ID .

    EQ              reduce using rule 15 (variable -> ID .)
    <               reduce using rule 15 (variable -> ID .)
    >               reduce using rule 15 (variable -> ID .)
    GE              reduce using rule 15 (variable -> ID .)
    LE              reduce using rule 15 (variable -> ID .)
    )               reduce using rule 15 (variable -> ID .)


state 16

    (18) assign -> ID = ID .

    IF              reduce using rule 18 (assign -> ID = ID .)
    ID              reduce using rule 18 (assign -> ID = ID .)
    $end            reduce using rule 18 (assign -> ID = ID .)
    }               reduce using rule 18 (assign -> ID = ID .)


state 17

    (17) assign -> ID = INTNUM .
    (20) EXPRESSION -> INTNUM . + INTNUM

    IF              reduce using rule 17 (assign -> ID = INTNUM .)
    ID              reduce using rule 17 (assign -> ID = INTNUM .)
    $end            reduce using rule 17 (assign -> ID = INTNUM .)
    }               reduce using rule 17 (assign -> ID = INTNUM .)
    +               shift and go to state 26


state 18

    (19) assign -> ID = EXPRESSION .

    IF              reduce using rule 19 (assign -> ID = EXPRESSION .)
    ID              reduce using rule 19 (assign -> ID = EXPRESSION .)
    $end            reduce using rule 19 (assign -> ID = EXPRESSION .)
    }               reduce using rule 19 (assign -> ID = EXPRESSION .)


state 19

    (7) if_statement -> IF ( condition ) . { instructions }

    {               shift and go to state 27


state 20

    (8) condition -> variable logical_operator . variable
    (14) variable -> . INTNUM
    (15) variable -> . ID

    INTNUM          shift and go to state 14
    ID              shift and go to state 15

    variable                       shift and go to state 28

state 21

    (9) logical_operator -> EQ .

    INTNUM          reduce using rule 9 (logical_operator -> EQ .)
    ID              reduce using rule 9 (logical_operator -> EQ .)


state 22

    (10) logical_operator -> < .

    INTNUM          reduce using rule 10 (logical_operator -> < .)
    ID              reduce using rule 10 (logical_operator -> < .)


state 23

    (11) logical_operator -> > .

    INTNUM          reduce using rule 11 (logical_operator -> > .)
    ID              reduce using rule 11 (logical_operator -> > .)


state 24

    (12) logical_operator -> GE .

    INTNUM          reduce using rule 12 (logical_operator -> GE .)
    ID              reduce using rule 12 (logical_operator -> GE .)


state 25

    (13) logical_operator -> LE .

    INTNUM          reduce using rule 13 (logical_operator -> LE .)
    ID              reduce using rule 13 (logical_operator -> LE .)


state 26

    (20) EXPRESSION -> INTNUM + . INTNUM

    INTNUM          shift and go to state 29


state 27

    (7) if_statement -> IF ( condition ) { . instructions }
    (4) instructions -> . instructions instruction
    (5) instructions -> . instruction
    (6) instruction -> . if_statement
    (16) instruction -> . assign
    (7) if_statement -> . IF ( condition ) { instructions }
    (17) assign -> . ID = INTNUM
    (18) assign -> . ID = ID
    (19) assign -> . ID = EXPRESSION

    IF              shift and go to state 7
    ID              shift and go to state 8

    instructions                   shift and go to state 30
    instruction                    shift and go to state 4
    if_statement                   shift and go to state 5
    assign                         shift and go to state 6

state 28

    (8) condition -> variable logical_operator variable .

    )               reduce using rule 8 (condition -> variable logical_operator variable .)


state 29

    (20) EXPRESSION -> INTNUM + INTNUM .

    IF              reduce using rule 20 (EXPRESSION -> INTNUM + INTNUM .)
    ID              reduce using rule 20 (EXPRESSION -> INTNUM + INTNUM .)
    $end            reduce using rule 20 (EXPRESSION -> INTNUM + INTNUM .)
    }               reduce using rule 20 (EXPRESSION -> INTNUM + INTNUM .)


state 30

    (7) if_statement -> IF ( condition ) { instructions . }
    (4) instructions -> instructions . instruction
    (6) instruction -> . if_statement
    (16) instruction -> . assign
    (7) if_statement -> . IF ( condition ) { instructions }
    (17) assign -> . ID = INTNUM
    (18) assign -> . ID = ID
    (19) assign -> . ID = EXPRESSION

    }               shift and go to state 31
    IF              shift and go to state 7
    ID              shift and go to state 8

    instruction                    shift and go to state 9
    if_statement                   shift and go to state 5
    assign                         shift and go to state 6

state 31

    (7) if_statement -> IF ( condition ) { instructions } .

    IF              reduce using rule 7 (if_statement -> IF ( condition ) { instructions } .)
    ID              reduce using rule 7 (if_statement -> IF ( condition ) { instructions } .)
    $end            reduce using rule 7 (if_statement -> IF ( condition ) { instructions } .)
    }               reduce using rule 7 (if_statement -> IF ( condition ) { instructions } .)

